(window.webpackJsonp=window.webpackJsonp||[]).push([[262],{611:function(t,e,s){"use strict";s.r(e);var a=s(42),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"开启调试动态请求参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#开启调试动态请求参数"}},[t._v("#")]),t._v(" 开启调试动态请求参数")]),t._v(" "),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),s("p",[s("code",[t._v("knife4j")]),t._v(" 版本>2.0.1 使用此规则")])]),t._v(" "),s("p",[t._v("在某些特定的情况下,因为我们对于接口使用的是一种先定义,后展示的规范执行,所以我们在界面上看到的请求参数,全部来源于我们后端接口层如何定义")]),t._v(" "),s("p",[t._v("但是如果后端定义的是一种Map结构,或者是参数并没有定义声明,而希望也能达到一种动态添加参数进行调试的结果,这种体验有点类似于"),s("code",[t._v("postman")])]),t._v(" "),s("p",[s("code",[t._v("Knife4j")]),t._v("针对上面的需求提供了支持")]),t._v(" "),s("p",[t._v("在"),s("code",[t._v("Knife4j")]),t._v("的前端页面中,个性化设置功能里,可以开启对参数的动态调试("),s("code",[t._v("该选项默认是关闭状态")]),t._v(")，如下图：")]),t._v(" "),s("p",[s("img",{attrs:{src:"/knife4j/images/knife4j/plus/debugDynamic.png",alt:""}})]),t._v(" "),s("p",[t._v("当在配置中勾选该选项后,我们的接口栏会有变化,如下图：")]),t._v(" "),s("p",[s("img",{attrs:{src:"/knife4j/images/knife4j/plus/debugDynamic1.png",alt:""}})]),t._v(" "),s("p",[t._v("在原本已存在的参数栏下会出现一栏空的参数栏,开发者可以输入参数名称、参数值对参数进行添加")]),t._v(" "),s("p",[t._v("不管是参数名称的变化还是参数值的变化,变化后会自动追加一行新的调试栏参数,效果图如下：")]),t._v(" "),s("p",[s("img",{attrs:{src:"/images/knife4j/plus/dynamicparam3.gif",alt:""}})]),t._v(" "),s("comment-comment")],1)}),[],!1,null,null,null);e.default=n.exports}}]);